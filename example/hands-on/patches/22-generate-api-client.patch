diff --git a/openapitools.json b/openapitools.json
new file mode 100644
index 0000000..d2fdbae
--- /dev/null
+++ b/openapitools.json
@@ -0,0 +1,7 @@
+{
+  "$schema": "node_modules/@openapitools/openapi-generator-cli/config.schema.json",
+  "spaces": 2,
+  "generator-cli": {
+    "version": "5.1.1"
+  }
+}
diff --git a/src/backend/config.ts b/src/backend/config.ts
new file mode 100644
index 0000000..c0615d0
--- /dev/null
+++ b/src/backend/config.ts
@@ -0,0 +1,2 @@
+import {Configuration} from './generated-rest-client';
+export const config = new Configuration({basePath: 'http://LOCALHOST:9080/api'});
diff --git a/src/backend/generated-rest-client/.openapi-generator-ignore b/src/backend/generated-rest-client/.openapi-generator-ignore
new file mode 100644
index 0000000..7484ee5
--- /dev/null
+++ b/src/backend/generated-rest-client/.openapi-generator-ignore
@@ -0,0 +1,23 @@
+# OpenAPI Generator Ignore
+# Generated by openapi-generator https://github.com/openapitools/openapi-generator
+
+# Use this file to prevent files from being overwritten by the generator.
+# The patterns follow closely to .gitignore or .dockerignore.
+
+# As an example, the C# client generator defines ApiClient.cs.
+# You can make changes and tell OpenAPI Generator to ignore just this file by uncommenting the following line:
+#ApiClient.cs
+
+# You can match any string of characters against a directory, file or extension with a single asterisk (*):
+#foo/*/qux
+# The above matches foo/bar/qux and foo/baz/qux, but not foo/bar/baz/qux
+
+# You can recursively match patterns against a directory, file or extension with a double asterisk (**):
+#foo/**/qux
+# This matches foo/bar/qux, foo/baz/qux, and foo/bar/baz/qux
+
+# You can also negate patterns with an exclamation (!).
+# For example, you can ignore all files in a docs folder with the file extension .md:
+#docs/*.md
+# Then explicitly reverse the ignore rule for a single file:
+#!docs/README.md
diff --git a/src/backend/generated-rest-client/.openapi-generator/FILES b/src/backend/generated-rest-client/.openapi-generator/FILES
new file mode 100644
index 0000000..ffa7cb1
--- /dev/null
+++ b/src/backend/generated-rest-client/.openapi-generator/FILES
@@ -0,0 +1,9 @@
+.openapi-generator-ignore
+apis/TodosApi.ts
+apis/index.ts
+index.ts
+models/NewTodo.ts
+models/Todo.ts
+models/TodoStatus.ts
+models/index.ts
+runtime.ts
diff --git a/src/backend/generated-rest-client/.openapi-generator/VERSION b/src/backend/generated-rest-client/.openapi-generator/VERSION
new file mode 100644
index 0000000..3bff059
--- /dev/null
+++ b/src/backend/generated-rest-client/.openapi-generator/VERSION
@@ -0,0 +1 @@
+5.1.1
\ No newline at end of file
diff --git a/src/backend/generated-rest-client/apis/TodosApi.ts b/src/backend/generated-rest-client/apis/TodosApi.ts
new file mode 100644
index 0000000..bd5e9df
--- /dev/null
+++ b/src/backend/generated-rest-client/apis/TodosApi.ts
@@ -0,0 +1,180 @@
+/* tslint:disable */
+/* eslint-disable */
+/**
+ * ToDo REST API
+ * ToDoアプリのREST API。
+ *
+ * The version of the OpenAPI document: 1.0.0
+ * 
+ *
+ * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
+ * https://openapi-generator.tech
+ * Do not edit the class manually.
+ */
+
+
+import * as runtime from '../runtime';
+import {
+    NewTodo,
+    NewTodoFromJSON,
+    NewTodoToJSON,
+    Todo,
+    TodoFromJSON,
+    TodoToJSON,
+    TodoStatus,
+    TodoStatusFromJSON,
+    TodoStatusToJSON,
+} from '../models';
+
+export interface DeleteTodoRequest {
+    todoId: number;
+}
+
+export interface PostTodoRequest {
+    newTodo: NewTodo;
+}
+
+export interface PutTodoRequest {
+    todoId: number;
+    todoStatus: TodoStatus;
+}
+
+/**
+ * 
+ */
+export class TodosApi extends runtime.BaseAPI {
+
+    /**
+     * 登録しているToDoを削除する。 
+     * ToDoの削除
+     */
+    async deleteTodoRaw(requestParameters: DeleteTodoRequest): Promise<runtime.ApiResponse<void>> {
+        if (requestParameters.todoId === null || requestParameters.todoId === undefined) {
+            throw new runtime.RequiredError('todoId','Required parameter requestParameters.todoId was null or undefined when calling deleteTodo.');
+        }
+
+        const queryParameters: any = {};
+
+        const headerParameters: runtime.HTTPHeaders = {};
+
+        const response = await this.request({
+            path: `/todos/{todoId}`.replace(`{${"todoId"}}`, encodeURIComponent(String(requestParameters.todoId))),
+            method: 'DELETE',
+            headers: headerParameters,
+            query: queryParameters,
+        });
+
+        return new runtime.VoidApiResponse(response);
+    }
+
+    /**
+     * 登録しているToDoを削除する。 
+     * ToDoの削除
+     */
+    async deleteTodo(requestParameters: DeleteTodoRequest): Promise<void> {
+        await this.deleteTodoRaw(requestParameters);
+    }
+
+    /**
+     * 登録しているToDoを全て取得する。 
+     * ToDo一覧の取得
+     */
+    async getTodosRaw(): Promise<runtime.ApiResponse<Array<Todo>>> {
+        const queryParameters: any = {};
+
+        const headerParameters: runtime.HTTPHeaders = {};
+
+        const response = await this.request({
+            path: `/todos`,
+            method: 'GET',
+            headers: headerParameters,
+            query: queryParameters,
+        });
+
+        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TodoFromJSON));
+    }
+
+    /**
+     * 登録しているToDoを全て取得する。 
+     * ToDo一覧の取得
+     */
+    async getTodos(): Promise<Array<Todo>> {
+        const response = await this.getTodosRaw();
+        return await response.value();
+    }
+
+    /**
+     * ToDoを登録する。 
+     * ToDoの登録
+     */
+    async postTodoRaw(requestParameters: PostTodoRequest): Promise<runtime.ApiResponse<Todo>> {
+        if (requestParameters.newTodo === null || requestParameters.newTodo === undefined) {
+            throw new runtime.RequiredError('newTodo','Required parameter requestParameters.newTodo was null or undefined when calling postTodo.');
+        }
+
+        const queryParameters: any = {};
+
+        const headerParameters: runtime.HTTPHeaders = {};
+
+        headerParameters['Content-Type'] = 'application/json';
+
+        const response = await this.request({
+            path: `/todos`,
+            method: 'POST',
+            headers: headerParameters,
+            query: queryParameters,
+            body: NewTodoToJSON(requestParameters.newTodo),
+        });
+
+        return new runtime.JSONApiResponse(response, (jsonValue) => TodoFromJSON(jsonValue));
+    }
+
+    /**
+     * ToDoを登録する。 
+     * ToDoの登録
+     */
+    async postTodo(requestParameters: PostTodoRequest): Promise<Todo> {
+        const response = await this.postTodoRaw(requestParameters);
+        return await response.value();
+    }
+
+    /**
+     * ToDoのステータスを更新する。 
+     * ToDoステータスの更新
+     */
+    async putTodoRaw(requestParameters: PutTodoRequest): Promise<runtime.ApiResponse<Todo>> {
+        if (requestParameters.todoId === null || requestParameters.todoId === undefined) {
+            throw new runtime.RequiredError('todoId','Required parameter requestParameters.todoId was null or undefined when calling putTodo.');
+        }
+
+        if (requestParameters.todoStatus === null || requestParameters.todoStatus === undefined) {
+            throw new runtime.RequiredError('todoStatus','Required parameter requestParameters.todoStatus was null or undefined when calling putTodo.');
+        }
+
+        const queryParameters: any = {};
+
+        const headerParameters: runtime.HTTPHeaders = {};
+
+        headerParameters['Content-Type'] = 'application/json';
+
+        const response = await this.request({
+            path: `/todos/{todoId}`.replace(`{${"todoId"}}`, encodeURIComponent(String(requestParameters.todoId))),
+            method: 'PUT',
+            headers: headerParameters,
+            query: queryParameters,
+            body: TodoStatusToJSON(requestParameters.todoStatus),
+        });
+
+        return new runtime.JSONApiResponse(response, (jsonValue) => TodoFromJSON(jsonValue));
+    }
+
+    /**
+     * ToDoのステータスを更新する。 
+     * ToDoステータスの更新
+     */
+    async putTodo(requestParameters: PutTodoRequest): Promise<Todo> {
+        const response = await this.putTodoRaw(requestParameters);
+        return await response.value();
+    }
+
+}
diff --git a/src/backend/generated-rest-client/apis/index.ts b/src/backend/generated-rest-client/apis/index.ts
new file mode 100644
index 0000000..70045d4
--- /dev/null
+++ b/src/backend/generated-rest-client/apis/index.ts
@@ -0,0 +1 @@
+export * from './TodosApi';
diff --git a/src/backend/generated-rest-client/index.ts b/src/backend/generated-rest-client/index.ts
new file mode 100644
index 0000000..848ecfa
--- /dev/null
+++ b/src/backend/generated-rest-client/index.ts
@@ -0,0 +1,3 @@
+export * from './runtime';
+export * from './apis';
+export * from './models';
diff --git a/src/backend/generated-rest-client/models/NewTodo.ts b/src/backend/generated-rest-client/models/NewTodo.ts
new file mode 100644
index 0000000..b0e8838
--- /dev/null
+++ b/src/backend/generated-rest-client/models/NewTodo.ts
@@ -0,0 +1,57 @@
+/* tslint:disable */
+/* eslint-disable */
+/**
+ * ToDo REST API
+ * ToDoアプリのREST API。
+ *
+ * The version of the OpenAPI document: 1.0.0
+ * 
+ *
+ * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
+ * https://openapi-generator.tech
+ * Do not edit the class manually.
+ */
+
+import { exists, mapValues } from '../runtime';
+/**
+ * ToDoの登録情報
+ * @export
+ * @interface NewTodo
+ */
+export interface NewTodo {
+    /**
+     * ToDoの内容
+     * @type {string}
+     * @memberof NewTodo
+     */
+    text: string;
+}
+
+export function NewTodoFromJSON(json: any): NewTodo {
+    return NewTodoFromJSONTyped(json, false);
+}
+
+export function NewTodoFromJSONTyped(json: any, ignoreDiscriminator: boolean): NewTodo {
+    if ((json === undefined) || (json === null)) {
+        return json;
+    }
+    return {
+        
+        'text': json['text'],
+    };
+}
+
+export function NewTodoToJSON(value?: NewTodo | null): any {
+    if (value === undefined) {
+        return undefined;
+    }
+    if (value === null) {
+        return null;
+    }
+    return {
+        
+        'text': value.text,
+    };
+}
+
+
diff --git a/src/backend/generated-rest-client/models/Todo.ts b/src/backend/generated-rest-client/models/Todo.ts
new file mode 100644
index 0000000..67b470d
--- /dev/null
+++ b/src/backend/generated-rest-client/models/Todo.ts
@@ -0,0 +1,73 @@
+/* tslint:disable */
+/* eslint-disable */
+/**
+ * ToDo REST API
+ * ToDoアプリのREST API。
+ *
+ * The version of the OpenAPI document: 1.0.0
+ * 
+ *
+ * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
+ * https://openapi-generator.tech
+ * Do not edit the class manually.
+ */
+
+import { exists, mapValues } from '../runtime';
+/**
+ * ToDo情報
+ * @export
+ * @interface Todo
+ */
+export interface Todo {
+    /**
+     * ToDoのID
+     * @type {number}
+     * @memberof Todo
+     */
+    id: number;
+    /**
+     * ToDoのタイトル
+     * @type {string}
+     * @memberof Todo
+     */
+    text: string;
+    /**
+     * ToDoのステータス
+     * @type {boolean}
+     * @memberof Todo
+     */
+    completed: boolean;
+}
+
+export function TodoFromJSON(json: any): Todo {
+    return TodoFromJSONTyped(json, false);
+}
+
+export function TodoFromJSONTyped(json: any, ignoreDiscriminator: boolean): Todo {
+    if ((json === undefined) || (json === null)) {
+        return json;
+    }
+    return {
+        
+        'id': json['id'],
+        'text': json['text'],
+        'completed': json['completed'],
+    };
+}
+
+export function TodoToJSON(value?: Todo | null): any {
+    if (value === undefined) {
+        return undefined;
+    }
+    if (value === null) {
+        return null;
+    }
+    return {
+        
+        'id': value.id,
+        'text': value.text,
+        'completed': value.completed,
+    };
+}
+
+
diff --git a/src/backend/generated-rest-client/models/TodoStatus.ts b/src/backend/generated-rest-client/models/TodoStatus.ts
new file mode 100644
index 0000000..49419a5
--- /dev/null
+++ b/src/backend/generated-rest-client/models/TodoStatus.ts
@@ -0,0 +1,57 @@
+/* tslint:disable */
+/* eslint-disable */
+/**
+ * ToDo REST API
+ * ToDoアプリのREST API。
+ *
+ * The version of the OpenAPI document: 1.0.0
+ * 
+ *
+ * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
+ * https://openapi-generator.tech
+ * Do not edit the class manually.
+ */
+
+import { exists, mapValues } from '../runtime';
+/**
+ * ToDoのステータス
+ * @export
+ * @interface TodoStatus
+ */
+export interface TodoStatus {
+    /**
+     * ToDoのステータス
+     * @type {boolean}
+     * @memberof TodoStatus
+     */
+    completed: boolean;
+}
+
+export function TodoStatusFromJSON(json: any): TodoStatus {
+    return TodoStatusFromJSONTyped(json, false);
+}
+
+export function TodoStatusFromJSONTyped(json: any, ignoreDiscriminator: boolean): TodoStatus {
+    if ((json === undefined) || (json === null)) {
+        return json;
+    }
+    return {
+        
+        'completed': json['completed'],
+    };
+}
+
+export function TodoStatusToJSON(value?: TodoStatus | null): any {
+    if (value === undefined) {
+        return undefined;
+    }
+    if (value === null) {
+        return null;
+    }
+    return {
+        
+        'completed': value.completed,
+    };
+}
+
+
diff --git a/src/backend/generated-rest-client/models/index.ts b/src/backend/generated-rest-client/models/index.ts
new file mode 100644
index 0000000..f6a419d
--- /dev/null
+++ b/src/backend/generated-rest-client/models/index.ts
@@ -0,0 +1,3 @@
+export * from './NewTodo';
+export * from './Todo';
+export * from './TodoStatus';
diff --git a/src/backend/generated-rest-client/runtime.ts b/src/backend/generated-rest-client/runtime.ts
new file mode 100644
index 0000000..423bdc6
--- /dev/null
+++ b/src/backend/generated-rest-client/runtime.ts
@@ -0,0 +1,319 @@
+/* tslint:disable */
+/* eslint-disable */
+/**
+ * ToDo REST API
+ * ToDoアプリのREST API。
+ *
+ * The version of the OpenAPI document: 1.0.0
+ * 
+ *
+ * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
+ * https://openapi-generator.tech
+ * Do not edit the class manually.
+ */
+
+
+export const BASE_PATH = "http://localhost:9080/api".replace(/\/+$/, "");
+
+const isBlob = (value: any) => typeof Blob !== 'undefined' && value instanceof Blob;
+
+/**
+ * This is the base class for all generated API classes.
+ */
+export class BaseAPI {
+
+    private middleware: Middleware[];
+
+    constructor(protected configuration = new Configuration()) {
+        this.middleware = configuration.middleware;
+    }
+
+    withMiddleware<T extends BaseAPI>(this: T, ...middlewares: Middleware[]) {
+        const next = this.clone<T>();
+        next.middleware = next.middleware.concat(...middlewares);
+        return next;
+    }
+
+    withPreMiddleware<T extends BaseAPI>(this: T, ...preMiddlewares: Array<Middleware['pre']>) {
+        const middlewares = preMiddlewares.map((pre) => ({ pre }));
+        return this.withMiddleware<T>(...middlewares);
+    }
+
+    withPostMiddleware<T extends BaseAPI>(this: T, ...postMiddlewares: Array<Middleware['post']>) {
+        const middlewares = postMiddlewares.map((post) => ({ post }));
+        return this.withMiddleware<T>(...middlewares);
+    }
+
+    protected async request(context: RequestOpts): Promise<Response> {
+        const { url, init } = this.createFetchParams(context);
+        const response = await this.fetchApi(url, init);
+        if (response.status >= 200 && response.status < 300) {
+            return response;
+        }
+        throw response;
+    }
+
+    private createFetchParams(context: RequestOpts) {
+        let url = this.configuration.basePath + context.path;
+        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
+            // only add the querystring to the URL if there are query parameters.
+            // this is done to avoid urls ending with a "?" character which buggy webservers
+            // do not handle correctly sometimes.
+            url += '?' + this.configuration.queryParamsStringify(context.query);
+        }
+        const body = ((typeof FormData !== "undefined" && context.body instanceof FormData) || context.body instanceof URLSearchParams || isBlob(context.body))
+        ? context.body
+        : JSON.stringify(context.body);
+
+        const headers = Object.assign({}, this.configuration.headers, context.headers);
+        const init = {
+            method: context.method,
+            headers: headers,
+            body,
+            credentials: this.configuration.credentials
+        };
+        return { url, init };
+    }
+
+    private fetchApi = async (url: string, init: RequestInit) => {
+        let fetchParams = { url, init };
+        for (const middleware of this.middleware) {
+            if (middleware.pre) {
+                fetchParams = await middleware.pre({
+                    fetch: this.fetchApi,
+                    ...fetchParams,
+                }) || fetchParams;
+            }
+        }
+        let response = await this.configuration.fetchApi(fetchParams.url, fetchParams.init);
+        for (const middleware of this.middleware) {
+            if (middleware.post) {
+                response = await middleware.post({
+                    fetch: this.fetchApi,
+                    url,
+                    init,
+                    response: response.clone(),
+                }) || response;
+            }
+        }
+        return response;
+    }
+
+    /**
+     * Create a shallow clone of `this` by constructing a new instance
+     * and then shallow cloning data members.
+     */
+    private clone<T extends BaseAPI>(this: T): T {
+        const constructor = this.constructor as any;
+        const next = new constructor(this.configuration);
+        next.middleware = this.middleware.slice();
+        return next;
+    }
+};
+
+export class RequiredError extends Error {
+    name: "RequiredError" = "RequiredError";
+    constructor(public field: string, msg?: string) {
+        super(msg);
+    }
+}
+
+export const COLLECTION_FORMATS = {
+    csv: ",",
+    ssv: " ",
+    tsv: "\t",
+    pipes: "|",
+};
+
+export type FetchAPI = WindowOrWorkerGlobalScope['fetch'];
+
+export interface ConfigurationParameters {
+    basePath?: string; // override base path
+    fetchApi?: FetchAPI; // override for fetch implementation
+    middleware?: Middleware[]; // middleware to apply before/after fetch requests
+    queryParamsStringify?: (params: HTTPQuery) => string; // stringify function for query strings
+    username?: string; // parameter for basic security
+    password?: string; // parameter for basic security
+    apiKey?: string | ((name: string) => string); // parameter for apiKey security
+    accessToken?: string | ((name?: string, scopes?: string[]) => string); // parameter for oauth2 security
+    headers?: HTTPHeaders; //header params we want to use on every request
+    credentials?: RequestCredentials; //value for the credentials param we want to use on each request
+}
+
+export class Configuration {
+    constructor(private configuration: ConfigurationParameters = {}) {}
+
+    get basePath(): string {
+        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
+    }
+
+    get fetchApi(): FetchAPI {
+        return this.configuration.fetchApi || window.fetch.bind(window);
+    }
+
+    get middleware(): Middleware[] {
+        return this.configuration.middleware || [];
+    }
+
+    get queryParamsStringify(): (params: HTTPQuery) => string {
+        return this.configuration.queryParamsStringify || querystring;
+    }
+
+    get username(): string | undefined {
+        return this.configuration.username;
+    }
+
+    get password(): string | undefined {
+        return this.configuration.password;
+    }
+
+    get apiKey(): ((name: string) => string) | undefined {
+        const apiKey = this.configuration.apiKey;
+        if (apiKey) {
+            return typeof apiKey === 'function' ? apiKey : () => apiKey;
+        }
+        return undefined;
+    }
+
+    get accessToken(): ((name: string, scopes?: string[]) => string) | undefined {
+        const accessToken = this.configuration.accessToken;
+        if (accessToken) {
+            return typeof accessToken === 'function' ? accessToken : () => accessToken;
+        }
+        return undefined;
+    }
+
+    get headers(): HTTPHeaders | undefined {
+        return this.configuration.headers;
+    }
+
+    get credentials(): RequestCredentials | undefined {
+        return this.configuration.credentials;
+    }
+}
+
+export type Json = any;
+export type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD';
+export type HTTPHeaders = { [key: string]: string };
+export type HTTPQuery = { [key: string]: string | number | null | boolean | Array<string | number | null | boolean> | HTTPQuery };
+export type HTTPBody = Json | FormData | URLSearchParams;
+export type ModelPropertyNaming = 'camelCase' | 'snake_case' | 'PascalCase' | 'original';
+
+export interface FetchParams {
+    url: string;
+    init: RequestInit;
+}
+
+export interface RequestOpts {
+    path: string;
+    method: HTTPMethod;
+    headers: HTTPHeaders;
+    query?: HTTPQuery;
+    body?: HTTPBody;
+}
+
+export function exists(json: any, key: string) {
+    const value = json[key];
+    return value !== null && value !== undefined;
+}
+
+export function querystring(params: HTTPQuery, prefix: string = ''): string {
+    return Object.keys(params)
+        .map((key) => {
+            const fullKey = prefix + (prefix.length ? `[${key}]` : key);
+            const value = params[key];
+            if (value instanceof Array) {
+                const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))
+                    .join(`&${encodeURIComponent(fullKey)}=`);
+                return `${encodeURIComponent(fullKey)}=${multiValue}`;
+            }
+            if (value instanceof Date) {
+                return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
+            }
+            if (value instanceof Object) {
+                return querystring(value as HTTPQuery, fullKey);
+            }
+            return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
+        })
+        .filter(part => part.length > 0)
+        .join('&');
+}
+
+export function mapValues(data: any, fn: (item: any) => any) {
+  return Object.keys(data).reduce(
+    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),
+    {}
+  );
+}
+
+export function canConsumeForm(consumes: Consume[]): boolean {
+    for (const consume of consumes) {
+        if ('multipart/form-data' === consume.contentType) {
+            return true;
+        }
+    }
+    return false;
+}
+
+export interface Consume {
+    contentType: string
+}
+
+export interface RequestContext {
+    fetch: FetchAPI;
+    url: string;
+    init: RequestInit;
+}
+
+export interface ResponseContext {
+    fetch: FetchAPI;
+    url: string;
+    init: RequestInit;
+    response: Response;
+}
+
+export interface Middleware {
+    pre?(context: RequestContext): Promise<FetchParams | void>;
+    post?(context: ResponseContext): Promise<Response | void>;
+}
+
+export interface ApiResponse<T> {
+    raw: Response;
+    value(): Promise<T>;
+}
+
+export interface ResponseTransformer<T> {
+    (json: any): T;
+}
+
+export class JSONApiResponse<T> {
+    constructor(public raw: Response, private transformer: ResponseTransformer<T> = (jsonValue: any) => jsonValue) {}
+
+    async value(): Promise<T> {
+        return this.transformer(await this.raw.json());
+    }
+}
+
+export class VoidApiResponse {
+    constructor(public raw: Response) {}
+
+    async value(): Promise<void> {
+        return undefined;
+    }
+}
+
+export class BlobApiResponse {
+    constructor(public raw: Response) {}
+
+    async value(): Promise<Blob> {
+        return await this.raw.blob();
+    };
+}
+
+export class TextApiResponse {
+    constructor(public raw: Response) {}
+
+    async value(): Promise<string> {
+        return await this.raw.text();
+    };
+}
diff --git a/src/backend/index.ts b/src/backend/index.ts
new file mode 100644
index 0000000..b7ad1a6
--- /dev/null
+++ b/src/backend/index.ts
@@ -0,0 +1,2 @@
+export * from './generated-rest-client';
+export * from './config';
